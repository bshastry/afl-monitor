#! /usr/bin/python
#
# Extended monitoring and reporting tool for AFL
# -------------------------------------------------
#
# Written and maintained by Paul S. Ziegler
#
# Copyright 2017 Reflare Ltd. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at:
#
#   http://www.apache.org/licenses/LICENSE-2.0
#

from sys import argv,exit,stdout
from os import listdir,system,path
from time import sleep,time
import re, pickle

OPTIONS = {"nocolor": False, "commandline": False, "verbose": False, "html": False, "execute": False, "recursive": False, "directory": False, "findings": False}

# Pretty print function
COLORS = {"HEADER" : '\033[95m',
    "OKBLUE" : '\033[94m',
    "OKGREEN" : '\033[92m',
    "WARNING" : '\033[93m',
    "FAIL" : '\033[91m',
    "BOLD" : '\033[1m',
    "UNDERLINE" : '\033[4m',
    "ENDC" : '\033[0m'
}

def pprint(s):
    if OPTIONS["nocolor"]:
        ansi_escape = re.compile(r'\x1b[^m]*m')
        s = ansi_escape.sub('', s)
    print s

def secondsToTimestamp(seconds):
    m, s = divmod(seconds, 60)
    h, m = divmod(m, 60)
    if h > 100000:
        return "/"
    return "%d hours %02d minutes %02d seconds" % (h, m, s)


def printUsage():
    print """This program processes a findings directory generated by afl-fuzz
    and displays the findings in various formats

./afl-monitor [-n | --nocolor] [-c | --commandLine] [-v | --verbose] [-h | --html output_directory]
    [-e | --execute command] [-r | --recursive second_count]  findings_directory

The findings_directory parameter should point to an existing findings directory
contianing one or several state directories for any active or stopped instance
of afl-fuzz.

-n | --nocolor\t\tSupresses color output.

-c | --commandLine\tOutput to the command line (can be used with -h)

-v | --verbose\t\tShow per-fuzzer statistics in commandline mode.

-h | --html\t\tOutput in HTML format. output_directory must be an empty
                        directory in which the output files will be saved. Will generate 1
                        index.html file and several plot images. Enables graph plotting.

-e | --execute\t\tExecutes the provided command (use quotes if using arguments)
                        and passes the commandline output via stdin (pipe).
                        Useful in combination with --recursive option.

-r | --recursive\tRe-runs this script with all provided arguments every
                        'second_count' seconds.
"""

def printBanner():
    pprint(COLORS["BOLD"] + COLORS["OKGREEN"] + "afl-monitor" + " " + COLORS["ENDC"] + "Version 1.0" + COLORS["ENDC"])


# Parse options
for c in range(len(argv)):
    arg = argv[c]
    if arg == "-n" or arg == "--nocolor":
        OPTIONS["nocolor"] = True
    elif arg == "-c" or arg == "--commandLine":
        OPTIONS["commandline"] = True
    elif arg == "-v" or arg == "--verbose":
        OPTIONS["verbose"] = True
    elif arg == "-h" or arg == "--html":
        try:
            OPTIONS["html"] = argv[c+1]
        except:
            printUsage()
            print "\n\nERROR: No output directory specified for --html option!"
            exit()
    elif arg == "-e" or arg == "--execute":
        try:
            OPTIONS["execute"] = argv[c+1]
        except:
            printUsage()
            print "\n\nERROR: No command specified for --execute option!"
            exit()
    elif arg == "-r" or arg == "--recursive":
        try:
            OPTIONS["recursive"] = int(argv[c+1])
        except:
            printUsage()
            print "\n\nERROR: No time specified for --recursive option!"
            exit()
OPTIONS["findings"] = argv[-1]

# Logic checks
if OPTIONS["execute"] == False and OPTIONS["commandline"] == False and OPTIONS["html"] == False:
    printUsage()
    print "\n\nERROR: Need to specify at least one output method (-c | -h | -e)!"
    exit()

if OPTIONS["html"]:
    try:
        listdir(OPTIONS["html"])
    except:
        printUsage()
        print "\n\nERROR: Cannot access HTML output folder!"
        exit()

if OPTIONS["recursive"] != False and OPTIONS["recursive"] < 1:
    printUsage()
    print "\n\nERROR: The second_count argument used with the --recursive option must be at least 1!"
    exit()

try:
    listdir(OPTIONS["findings"])
except:
    printUsage()
    print "\n\nERROR: Cannot access findings_directory!"
    exit()

printBanner()

# Recursive Loop
if OPTIONS["recursive"]:
    argv_string = ""
    c = 0
    while c < len(argv):
        arg = argv[c]
        if arg == "-r" or arg == "--recursive":
            c += 2
            continue
        argv_string += " %s" % arg
        c += 1
    while True:
        print " "
        system("date")
        print "============="
        system(argv_string)
        sleep(OPTIONS["recursive"])

directories = listdir(OPTIONS["findings"])
directories.sort()
fuzzers = {}
for directory in directories:
    try:
        raw = open("%s/%s/fuzzer_stats" % (OPTIONS["findings"], directory)).read().split("\n")
        data = {}
        for line in raw:
            if line == "":
                continue
            parts = line.split(":")
            data[parts[0].strip()] = parts[1].strip()
        fuzzers[directory] = data
    except:
        pass


DATA = {}
DATA["totalFuzzers"] = len(fuzzers)
DATA["aliveFuzzers"] = 0
DATA["totalExecs"] = 0
DATA["totalSpeed"] = 0
DATA["pendingGeneral"] = 0
DATA["pendingFavorite"] = 0
DATA["pathsTotal"] = 0
DATA["pathsFavorite"] = 0
DATA["totalStability"] = 0
DATA["leastStable"] = 100
DATA["mostStable"] = 0
DATA["lastPath"] = 0
DATA["lastCrash"] = 0
DATA["lastHang"] = 0
DATA["crashes"] = 0
DATA["hangs"] = 0
DATA["totalCycles"] = 0
DATA["maxCycle"] = 0
PREVIOUS = DATA
now = time()
for k,v in fuzzers.iteritems():
    isAlive = False
    if path.isdir("/proc/%s" % v["fuzzer_pid"]):
        isAlive = True
    if isAlive:
        DATA["aliveFuzzers"] += 1
        DATA["totalSpeed"] += float(v["execs_per_sec"])
    DATA["pendingGeneral"] += int(v["pending_total"])
    DATA["pendingFavorite"] += int(v["pending_favs"])
    DATA["pathsTotal"] += int(v["paths_total"])
    DATA["pathsFavorite"] += int(v["paths_favored"])
    DATA["totalExecs"] += int(v["execs_done"])
    stability = float(v["stability"].replace("%",""))
    DATA["totalStability"] += stability
    if stability < DATA["leastStable"]:
        DATA["leastStable"] = stability
    if stability > DATA["mostStable"]:
        DATA["mostStable"] = stability
    if int(v["last_path"]) > DATA["lastPath"]:
        DATA["lastPath"] = int(v["last_path"])
    if int(v["last_crash"]) > DATA["lastCrash"]:
        DATA["lastCrash"] = int(v["last_crash"])
    if int(v["last_hang"]) > DATA["lastHang"]:
        DATA["lastHang"] = int(v["last_hang"])
    DATA["crashes"] += int(v["unique_crashes"])
    DATA["hangs"] += int(v["unique_hangs"])
    DATA["totalCycles"] += int(v["cycles_done"])
    if int(v["cycles_done"]) > DATA["maxCycle"]:
        DATA["maxCycle"] = int(v["cycles_done"])

    if OPTIONS["commandline"] and OPTIONS["verbose"]:
        pprint("")
        pprint("%s%s[ %s%s%s %s]%s" % (COLORS["BOLD"], COLORS["OKBLUE"], COLORS["ENDC"], COLORS["BOLD"], v["afl_banner"], COLORS["OKBLUE"], COLORS["ENDC"]))
        if isAlive:
            pprint("Status:%s\t\t\t%sALIVE%s" % (COLORS["BOLD"], COLORS["OKGREEN"], COLORS["ENDC"]))
        else:
            pprint("Status:%s\t\t\t%sDEAD%s" % (COLORS["BOLD"], COLORS["FAIL"], COLORS["ENDC"]))
        pprint("Executions:\t\t%s%s%s" % (COLORS["BOLD"],'{:,}'.format(int(v["execs_done"])),COLORS["ENDC"]))
        if isAlive:
            pprint("Current Speed:\t\t%s%s%s execs/second" % (COLORS["BOLD"],'{:,.2f}'.format(float(v["execs_per_sec"])),COLORS["ENDC"]))
        pprint("Paths Found (Favs/All):\t%s%s%s / %s%s%s" % (COLORS["BOLD"],'{:,}'.format(int(v["paths_favored"])),COLORS["ENDC"],COLORS["BOLD"],'{:,}'.format(int(v["paths_total"])),COLORS["ENDC"]))
        pprint("Pending (Favs/All):\t%s%s%s / %s%s%s" % (COLORS["BOLD"],'{:,}'.format(int(v["pending_favs"])),COLORS["ENDC"],COLORS["BOLD"],'{:,}'.format(int(v["pending_total"])),COLORS["ENDC"]))
        pprint("Stability:\t\t%s%s%s" % (COLORS["BOLD"], v["stability"], COLORS["ENDC"]))
        pprint("Cycle:\t\t\t%s%d%s" % (COLORS["BOLD"], int(v["cycles_done"]),COLORS["ENDC"]))
        pprint("Last Path:\t\t%s%s%s ago" % (COLORS["BOLD"], secondsToTimestamp(now - float(v["last_path"])), COLORS["ENDC"]))
        pprint("Last Hang:\t\t%s%s%s ago" % (COLORS["BOLD"], secondsToTimestamp(now - float(v["last_hang"])), COLORS["ENDC"]))
        pprint("Last Crash:\t\t%s%s%s ago" % (COLORS["BOLD"], secondsToTimestamp(now - float(v["last_crash"])), COLORS["ENDC"]))
        pprint("Unique Crashes:\t\t%s%s%d%s" % (COLORS["BOLD"],COLORS["FAIL"],int(v["unique_crashes"]),COLORS["ENDC"]))

try:
    PREVIOUS = pickle.load(open(".afl-monitor.state"))
except:
    pass

def makeDeltaString(value):
    if value > 0.01:
        return "%s (+%s)%s" % (COLORS["OKGREEN"], '{:,.2f}'.format(value), COLORS["ENDC"])
    if value < -0.01:
        return "%s (%s)%s" % (COLORS["FAIL"], '{:,.2f}'.format(value), COLORS["ENDC"])
    return ""

if OPTIONS["commandline"]:
    pprint("")
    pprint("%s%s[%s%s SUMMARY %s]%s" % (COLORS["BOLD"], COLORS["OKBLUE"], COLORS["ENDC"], COLORS["BOLD"], COLORS["OKBLUE"], COLORS["ENDC"]))
    deltaAliveFuzzers = DATA["aliveFuzzers"] - PREVIOUS["aliveFuzzers"]
    deltaTotalFuzzers = DATA["totalFuzzers"] - PREVIOUS["totalFuzzers"]
    pprint("Fuzzers (Alive/Total):\t%s%d%s%s / %s%d%s%s" % (COLORS["BOLD"], DATA["aliveFuzzers"], makeDeltaString(deltaAliveFuzzers), COLORS["ENDC"],COLORS["BOLD"], DATA["totalFuzzers"], makeDeltaString(deltaTotalFuzzers), COLORS["ENDC"]))
    deltaTotalExecs = DATA["totalExecs"] - PREVIOUS["totalExecs"]
    pprint("Total Executions:\t%s%s%s%s" % (COLORS["BOLD"],'{:,}'.format(DATA["totalExecs"]),COLORS["ENDC"], makeDeltaString(deltaTotalExecs)))
    try:
        deltaTotalSpeed = DATA["totalSpeed"] - PREVIOUS["totalSpeed"]
        pprint("Current Speed:\t\t%s%s%s%s execs/second" % (COLORS["BOLD"],'{:,.2f}'.format(DATA["totalSpeed"]),COLORS["ENDC"], makeDeltaString(deltaTotalSpeed)))
    except:
        pprint("Current Speed:\t\t%s%s%s execs/second" % (COLORS["BOLD"],"0.00",COLORS["ENDC"]))
    deltaPathsFavorite = DATA["pathsFavorite"] - PREVIOUS["pathsFavorite"]
    deltaPathsTotal = DATA["pathsTotal"] - PREVIOUS["pathsTotal"]
    pprint("Paths Found (Favs/All):\t%s%s%s%s / %s%s%s%s" % (COLORS["BOLD"],'{:,}'.format(DATA["pathsFavorite"]),COLORS["ENDC"], makeDeltaString(deltaPathsFavorite),COLORS["BOLD"],'{:,}'.format(DATA["pathsTotal"]),COLORS["ENDC"], makeDeltaString(deltaPathsTotal)))
    deltaPendingFavorite = DATA["pendingFavorite"] - PREVIOUS["pendingFavorite"]
    deltaPendingGeneral = DATA["pendingGeneral"] - PREVIOUS["pendingGeneral"]
    pprint("Pending (Favs/All):\t%s%s%s%s / %s%s%s%s" % (COLORS["BOLD"],'{:,}'.format(DATA["pendingFavorite"]),COLORS["ENDC"], makeDeltaString(deltaPendingFavorite),COLORS["BOLD"],'{:,}'.format(DATA["pendingGeneral"]),COLORS["ENDC"], makeDeltaString(deltaPendingGeneral)))
    try:
        deltaAverageStability = (DATA["totalStability"] / DATA["totalFuzzers"]) - (PREVIOUS["totalStability"] / PREVIOUS["totalFuzzers"])
        pprint("Average Stability:\t%s%.2f%%%s%s" % (COLORS["BOLD"], DATA["totalStability"] / DATA["totalFuzzers"], COLORS["ENDC"], makeDeltaString(deltaAverageStability)))
    except:
        pass
    deltaMostStable = DATA["mostStable"] - PREVIOUS["mostStable"]
    pprint("Most Stable Fuzzer:\t%s%.2f%%%s%s" % (COLORS["BOLD"], DATA["mostStable"], COLORS["ENDC"], makeDeltaString(deltaMostStable)))
    deltaLeastStable = DATA["leastStable"] - PREVIOUS["leastStable"]
    pprint("Least Stable Fuzzer:\t%s%.2f%%%s%s" % (COLORS["BOLD"], DATA["leastStable"], COLORS["ENDC"], makeDeltaString(deltaLeastStable)))
    try:
        pprint("Average Cycle:\t\t%s%s%s" % (COLORS["BOLD"], int(float(DATA["totalCycles"]) / DATA["totalFuzzers"]),COLORS["ENDC"]))
    except:
        pass
    deltaMaxCycle = DATA["maxCycle"] - PREVIOUS["maxCycle"]
    pprint("Maximum Cycle:\t\t%s%s%s%s" % (COLORS["BOLD"], DATA["maxCycle"],COLORS["ENDC"], makeDeltaString(deltaMaxCycle)))
    pprint("Last Path:\t\t%s%s%s ago" % (COLORS["BOLD"], secondsToTimestamp(now - DATA["lastPath"]), COLORS["ENDC"]))
    pprint("Last Hang:\t\t%s%s%s ago" % (COLORS["BOLD"], secondsToTimestamp(now - DATA["lastHang"]), COLORS["ENDC"]))
    pprint("Last Crash:\t\t%s%s%s ago" % (COLORS["BOLD"], secondsToTimestamp(now - DATA["lastCrash"]), COLORS["ENDC"]))
    deltaUniqueCrashes = DATA["crashes"] - PREVIOUS["crashes"]
    pprint("Unique Crashes:\t\t%s%s%d%s%s" % (COLORS["BOLD"],COLORS["HEADER"],DATA["crashes"],COLORS["ENDC"], makeDeltaString(deltaUniqueCrashes)))

pickle.dump(DATA,open(".afl-monitor.state","w"))


#TODO
# [v] Console Mode Switch
# [v] Correct Alive Counter
# [] Web Output
# [] Graphing
# [v] Per-fuzzer output
# [v] Difference Indicator
# [v] High "hours ago" count without incidents
# [] Execute Option
